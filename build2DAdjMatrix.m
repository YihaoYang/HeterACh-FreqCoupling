function outMatrix = build2DAdjMatrix(inSideNum,circleId,strength)
% Function is only valid when circleId is 1 (used in the generation of gks
% maps) The correct method to generate the adjency matrix is in NeuroNets.py.
sideNum = inSideNum;
num = sideNum^2;
ID = 1:num;

ID = reshape(ID,[sideNum,sideNum]);
outMatrix = zeros(num);

I = 1:sideNum;
J = 1:sideNum;
if logical(mod(circleId,2))%if circleId is odd
    neighborID = [ID(I,((J-circleId) <= 0)*sideNum+J-circleId); ...
        ID(((I-circleId) <= 0)*sideNum+I-circleId,J); ...
        ID(((I+circleId)>sideNum)*(-sideNum)+I+circleId,J); ...
        ID(I,((J+circleId)>sideNum)*(-sideNum)+J+circleId)];
else
    neighborID = [ID(((I-circleId) <= 0)*sideNum+I-circleId, ...
        ((J-circleId) <= 0)*sideNum+J-circleId); ...
        ID(((I+circleId)>sideNum)*(-sideNum)+I+circleId, ...
        ((J-circleId) <= 0)*sideNum+J-circleId); ...
        ID(((I+circleId)>sideNum)*(-sideNum)+I+circleId, ...
        ((J+circleId)>sideNum)*(-sideNum)+J+circleId); ...
        ID(((I-circleId) <= 0)*sideNum+I-circleId, ...
        ((J+circleId)>sideNum)*(-sideNum)+J+circleId)];
end
ID = [ID;ID;ID;ID];
tempIdx = ID(:) + num * (neighborID(:) - 1);
outMatrix(tempIdx) = strength;
end